# Session Learnings - 2025-12-17

## Technical

### Plan File Structure
- **Learning:** Separating implementation specifications from planning documents improves clarity
- **Applied:** Created RHETORIC_ANALYZER_SPEC.md for code/implementation details, kept PLAN.md focused on task tracking
- **Benefit:** Plans stay scannable; specs remain comprehensive reference material

### Plan Document Design
- **Learning:** A good plan structure includes: Overview, Current Status, Steps with (Purpose, Status, Sub-tasks, Deliverables, Notes), and Quick Reference table
- **Pattern:** Each step should have clear deliverables - this makes completion criteria explicit
- **Pattern:** "Future" status for steps that are planned but not yet actionable

### Project Initialization
- **Learning:** The `/q-init` command creates a consistent folder structure for session tracking
- **Created:** docs/sessions/, docs/reference/, test-data/, scripts/
- **Created:** PLAN.md, COMPLETED_PLAN.md, CLI-REFERENCE.md, CLI-QUICKREF.md, CLI-TESTING.md

## Workflow

### Merging Plan Documents
- **Scenario:** Two plan files (PLAN.md template, PLANtom.md with content) needed consolidation
- **Approach:** Assessed structural compatibility first, then chose merge strategy (phases → steps)
- **Result:** Single authoritative PLAN.md with all content in consistent format

### Spec vs Plan Separation
- **Guideline:** ~95% implementation code in a "plan" file signals it should be a spec
- **Guideline:** Plans should track: what to do, status, next steps
- **Guideline:** Specs should contain: how to implement, code examples, data structures

## Documentation

### File Naming Conventions
- **Session files:** `YYYY-MM-DD_HH-MM-SS Learnings.md`
- **Spec files:** `PROJECT_NAME_SPEC.md` (e.g., RHETORIC_ANALYZER_SPEC.md)
- **Plan files:** `PLAN.md` (single authoritative plan per project)

### Reference Documentation
- CLI-QUICKREF.md: Quick lookup table for commands
- CLI-REFERENCE.md: Detailed documentation with examples
- CLI-TESTING.md: Test suite documentation
- Keep these in sync when CLI changes

## Architecture

### Embedding Rhetoric Analyzer Design Decisions
- **Result Format:** JSON with full provenance enables skill chaining
- **Configuration as Data:** JSON configs work across CLI, API, and agents
- **Exemplar Store:** Shared collections can be specialized per domain
- **Stateless Skills:** State lives in persisted results, not memory

### Future Integration Pattern (Skills/Agents)
- **Skills:** Focused capabilities with clear inputs/outputs
- **Agents:** Orchestrators that combine skills for complex tasks
- **Integration Path:** CLI tool → Skill extraction → Agent development → Web UI
